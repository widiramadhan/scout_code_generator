// ignore_for_file: prefer_adjacent_string_concatenation, prefer_interpolation_to_compose_strings, curly_braces_in_flow_control_structures, unused_local_variable, non_constant_identifier_names
import 'dart:io';
import 'dart:convert';
import 'package:path/path.dart' as p;
import 'package:recase/recase.dart';
import 'config.dart';
import 'json_model_generator.dart';

Future<void> generateUsecase({
  required Config config,
  required String featureName,
  required String usecaseName,
  required String author,
}) async {
  final rc = ReCase(usecaseName);
  final pascal = rc.pascalCase;
  final camel = rc.camelCase;
  final snake = rc.snakeCase;
  final today = DateTime.now();

  final featureSnake = ReCase(featureName).snakeCase;

  // 1. model dir
  final modelDir = config.model.replaceAll('features_name', featureSnake);
  Directory(modelDir).createSync(recursive: true);

  // request
  stdout.write("Apakah usecase ini mempunyai request? (y/n): ");
  final hasRequest = stdin.readLineSync()?.toLowerCase() == 'y';
  if (hasRequest) {
    final reqDir = p.join(modelDir, 'request');
    Directory(reqDir).createSync(recursive: true);

    // Prompt for JSON structure
    stdout.writeln(
      "Masukkan struktur JSON untuk request model, akhiri dengan END:",
    );
    final buffer = StringBuffer();
    while (true) {
      final line = stdin.readLineSync();
      if (line == 'END') break;
      buffer.writeln(line);
    }
    String jsonInput = buffer.toString();

    if (jsonInput.trim().isEmpty) {
      stdout.writeln(
        "[!] JSON tidak boleh kosong. Menggunakan template default.",
      );

      // Create default request file
      final reqFile = File(p.join(reqDir, '${snake}_request.dart'));
      reqFile.writeAsStringSync('''
/// Generated by scout
/// Author: $author
/// Date  : $today
/// File  : ${snake}_request.dart

import 'dart:convert';

class ${pascal}Request {
  // TODO: parse from json
  
  ${pascal}Request();
  
  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    return data;
  }
}
''');
      stdout.writeln('[✓] Default request model generated: ${reqFile.path}');
    } else {
      // Validate JSON
      try {
        final jsonData = json.decode(jsonInput);
        if (jsonData is! Map<String, dynamic>) {
          stdout.writeln(
            "[!] JSON harus berupa objek. Menggunakan template default.",
          );

          // Create default request file
          final reqFile = File(p.join(reqDir, '${snake}_request.dart'));
          reqFile.writeAsStringSync('''
/// Generated by scout
/// Author: $author
/// Date  : $today
/// File  : ${snake}_request.dart

import 'dart:convert';

class ${pascal}Request {
  // TODO: parse from json
  
  ${pascal}Request();
  
  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    return data;
  }
}
''');
          stdout.writeln(
            '[✓] Default request model generated: ${reqFile.path}',
          );
        } else {
          // Generate model from JSON
          final modelContent = generateModelFromJson(
            jsonData,
            pascal,
            modelType: 'request',
          );

          final reqFile = File(p.join(reqDir, '${snake}_request.dart'));
          reqFile.writeAsStringSync('''
/// Generated by scout
/// Author: $author
/// Date  : $today
/// File  : ${snake}_request.dart

import 'dart:convert';

$modelContent
''');
          stdout.writeln(
            '[✓] Request model berhasil dibuat dari JSON: ${reqFile.path}',
          );
        }
      } catch (e) {
        stdout.writeln(
          "[!] JSON tidak valid: $e. Menggunakan template default.",
        );

        // Create default request file
        final reqFile = File(p.join(reqDir, '${snake}_request.dart'));
        reqFile.writeAsStringSync('''
/// Generated by scout
/// Author: $author
/// Date  : $today
/// File  : ${snake}_request.dart

import 'dart:convert';

class ${pascal}Request {
  // TODO: parse from json
  
  ${pascal}Request();
  
  Map<String, dynamic> toJson() {
    final Map<String, dynamic> data = <String, dynamic>{};
    return data;
  }
}
''');
        stdout.writeln('[✓] Default request model generated: ${reqFile.path}');
      }
    }
  }

  // response
  stdout.write("Apakah usecase ini mempunyai response? (y/n): ");
  final hasResponse = stdin.readLineSync()?.toLowerCase() == 'y';
  if (hasResponse) {
    final resDir = p.join(modelDir, 'response');
    Directory(resDir).createSync(recursive: true);

    final ResponseFile = File(p.join(resDir, '${snake}_response.dart'));

    // Prompt for JSON structure
    stdout.writeln(
      "Masukkan struktur JSON untuk response model, akhiri dengan END:",
    );
    final buffer = StringBuffer();
    while (true) {
      final line = stdin.readLineSync();
      if (line == 'END') break;
      buffer.writeln(line);
    }
    String jsonInput = buffer.toString();

    if (jsonInput.trim().isEmpty) {
      stdout.writeln(
        "[!] JSON tidak boleh kosong. Proses generate dibatalkan.",
      );
      return;
    }

    // Validate JSON
    try {
      final jsonData = json.decode(jsonInput);
      if (jsonData is! Map<String, dynamic>) {
        stdout.writeln(
          "[!] JSON harus berupa objek. Proses generate dibatalkan.",
        );
        return;
      }

      // Generate model from JSON
      final modelContent = generateModelFromJson(jsonData, pascal);

      if (!ResponseFile.existsSync()) {
        ResponseFile.writeAsStringSync('''
/// Generated by scout
/// Author: $author
/// Date  : $today
/// File  : ${snake}_response.dart

import 'dart:convert';

$modelContent
''');
        stdout.writeln(
          "[✓] Response model berhasil dibuat: ${ResponseFile.path}",
        );
      }

      // Create entity directory and file
      final entityDir = config.entity.replaceAll('features_name', featureSnake);
      Directory(entityDir).createSync(recursive: true);

      final entityFile = File(p.join(entityDir, '${snake}_entity.dart'));

      // Generate entity content
      final featurePascal = ReCase(featureName).pascalCase;
      final entityContent = generateEntityFromModel(
        pascal, // use usecase name for Entity class (from response), not feature
        pascal,
        jsonData,
        '../../data/model/response/${snake}_response.dart',
      );

      if (!entityFile.existsSync()) {
        entityFile.writeAsStringSync('''
/// Generated by scout
/// Author: $author
/// Date  : $today
/// File  : ${snake}_entity.dart

import 'dart:convert';
import '${entityContent.import}';

${entityContent.classDefinition}
''');
        stdout.writeln("[✓] Entity berhasil dibuat: ${entityFile.path}");
      }
    } catch (e) {
      stdout.writeln("[!] JSON tidak valid: $e. Proses generate dibatalkan.");
      return;
    }
  }

  // Check if dio, fpdart, and logger packages are installed
  final pubspecFile = File('pubspec.yaml');
  if (pubspecFile.existsSync()) {
    var pubspecContent = pubspecFile.readAsStringSync();
    bool hasDio = pubspecContent.contains('dio:');
    bool hasFpdart = pubspecContent.contains('fpdart:');
    bool hasLogger = pubspecContent.contains('logger:');

    if (!hasDio || !hasFpdart || !hasLogger) {
      // Find the dependencies section
      final dependenciesMatch = RegExp(
        r'dependencies:\s*\n',
      ).firstMatch(pubspecContent);
      if (dependenciesMatch != null) {
        int insertPosition = dependenciesMatch.end;
        String packagesToAdd = '';

        if (!hasDio) {
          packagesToAdd += '  dio: ^5.0.0\n';
          stdout.writeln(
            "Package 'dio' tidak ditemukan di pubspec.yaml. Menambahkan secara otomatis...",
          );
        }

        if (!hasFpdart) {
          packagesToAdd += '  fpdart: ^1.1.0\n';
          stdout.writeln(
            "Package 'fpdart' tidak ditemukan di pubspec.yaml. Menambahkan secara otomatis...",
          );
        }

        if (!hasLogger) {
          packagesToAdd += '  logger: ^2.0.0\n';
          stdout.writeln(
            "Package 'logger' tidak ditemukan di pubspec.yaml. Menambahkan secara otomatis...",
          );
        }

        if (packagesToAdd.isNotEmpty) {
          pubspecContent =
              pubspecContent.substring(0, insertPosition) +
              packagesToAdd +
              pubspecContent.substring(insertPosition);
          pubspecFile.writeAsStringSync(pubspecContent);

          stdout.writeln("[✓] Package berhasil ditambahkan ke pubspec.yaml");
          stdout.writeln(
            "[!] Jangan lupa untuk menjalankan 'flutter pub get' setelah ini",
          );
        }
      }
    }
  }

  // Create core client directory if it doesn't exist
  final coreDir = p.join('lib', 'src', 'core');
  final clientDir = p.join(coreDir, 'client');
  Directory(clientDir).createSync(recursive: true);

  // Create core error directory if it doesn't exist
  final errorDir = p.join(coreDir, 'error');
  Directory(errorDir).createSync(recursive: true);

  // Create failures.dart if it doesn't exist
  final failureFile = File(p.join(errorDir, 'failures.dart'));
  if (!failureFile.existsSync()) {
    failureFile.writeAsStringSync('''
/// Generated by scout
/// Author: $author
/// Date  : $today
/// File  : failures.dart

import 'package:dio/dio.dart';

abstract class Failure implements Exception {
  DioExceptionType? type;
  int? status;
  String? message;
  bool? isConfirm;

  Failure({this.message, this.status, this.type, this.isConfirm});
}

class GeneralFailure extends Failure {
  GeneralFailure({super.message, super.status, super.type, super.isConfirm});
}

class UnAuthorizedFailure extends Failure {
  UnAuthorizedFailure(
      {super.message, super.status, super.type, super.isConfirm});
}
''');
    stdout.writeln('[✓] Failure class generated: ${failureFile.path}');
  }

  // Create remote_process.dart if it doesn't exist
  final remoteProcessFile = File(p.join(errorDir, 'remote_process.dart'));
  if (!remoteProcessFile.existsSync()) {
    remoteProcessFile.writeAsStringSync('''
/// Generated by scout
/// Author: $author
/// Date  : $today
/// File  : remote_process.dart

import 'package:dio/dio.dart';
import 'package:fpdart/fpdart.dart';
import 'package:flutter/foundation.dart';
import 'package:logger/logger.dart';
import 'failures.dart';

Future<Either<Failure, T>> remoteProcess<T>(Future<T> t) async {
  try {
    var futureCall = await t;
    return Right(futureCall);
  } on DioException catch (error) {
    try {
      Logger().e(error.response?.statusCode);
      Logger().e(error.response?.data['message']);
      Logger().e(error.response?.data['msg']);
      Logger().e(error.error);
    } catch (e) {
      if (kDebugMode) print({'Error ': e});
      return Left(
        GeneralFailure(
          message: "Internal Server Error",
          isConfirm: error.response?.data['is_confirm'] ?? false,
        ),
      );
    }
    if (error.error is UnAuthorizedFailure) {
      return Left(
        UnAuthorizedFailure(
          message: 'Session Anda sudah berakhir. Silahkan login kembali.',
          type: error.type,
          status: error.response?.statusCode ?? 0,
          isConfirm: error.response?.data['is_confirm'] ?? false,
        ),
      );
    } else {
      return Left(
        GeneralFailure(
          type: error.type,
          status: error.response?.statusCode ?? 0,
          message: getMessage(error.response),
          isConfirm: error.response?.data['is_confirm'] ?? false,
        ),
      );
    }
  } catch (error) {
    if (error is TypeError) {
      // Handle TypeError specifically
      return Left(
        GeneralFailure(
          message: 'Request failed due to type error',
          isConfirm: false,
        ),
      );
    }
    return Left(GeneralFailure(message: error.toString()));
  }
}

getMessage(Response? response) {
  switch (response?.statusCode) {
    case 400:
      return response?.data['message'] ?? 'Bad Request';
    case 401:
      return response?.data['message'] ?? 'Unauthorized';
    case 403:
      return response?.data['message'] ?? 'Forbidden';
    case 405:
      return response?.data['message'] ?? "Retry";
    case 404:
      return response?.data['message'] ?? 'Not Found';
    case 500:
      return response?.data['message'] ?? 'Internal Server Error';
    case 502:
      return 'Request Timeout';
    case 503:
      return 'Service Unavailable';
    case 504:
      return 'Sorry, Request Timeout';
    case 422:
      return 'Signature verification failed';
    default:
      return 'Problem communicating with the server.';
  }
}
''');
    stdout.writeln(
      '[✓] Remote process helper generated: ${remoteProcessFile.path}',
    );
  }

  // Check if api_path.dart exists and has baseUrl
  final apiPathFile = File(p.join(clientDir, 'api_path.dart'));
  String baseUrl = 'https://127.0.0.1';
  bool hasBaseUrl = false;

  if (apiPathFile.existsSync()) {
    final content = apiPathFile.readAsStringSync();
    hasBaseUrl = content.contains('static const String baseUrl');
  }

  if (!hasBaseUrl) {
    stdout.write("Masukan baseUrl (contoh: https://127.0.0.1): ");
    final userBaseUrl = stdin.readLineSync();
    if (userBaseUrl != null && userBaseUrl.isNotEmpty) {
      baseUrl = userBaseUrl;
    }
  }

  // endpoint
  stdout.write("Masukan endpoint contoh (api/v1/...): ");
  final endpoint = stdin.readLineSync() ?? '';

  // HTTP method for API call
  stdout.write("Pilih HTTP method (get/post/put/delete): ");
  final httpMethod = stdin.readLineSync()?.toLowerCase() ?? 'get';

  // usecase
  final usecaseDir = config.usecase.replaceAll('features_name', featureSnake);
  Directory(usecaseDir).createSync(recursive: true);

  // Compute usecase return type (Either)
  final bool isListUc =
      hasResponse && (pascal.endsWith('s') || pascal.contains('List'));
  final String returnTypeUc = hasResponse
      ? (isListUc
            ? "Either<Failure, List<${pascal}Entity>>"
            : "Either<Failure, ${pascal}Entity>")
      : "Either<Failure, void>";

  // Build usecase interface with conditional imports and Either return type
  final ucInterface = File(p.join(usecaseDir, '${snake}_usecase.dart'));
  String ucInterfaceContent =
      '''
/// Generated by scout
/// Author: $author
/// Date  : $today
/// File  : ${snake}_usecase.dart
''';
  if (hasRequest) {
    ucInterfaceContent +=
        "import '../../data/model/request/${snake}_request.dart';\n";
  }
  ucInterfaceContent += "import 'package:fpdart/fpdart.dart';\n";
  ucInterfaceContent += "import '../../../../core/error/failures.dart';\n";
  if (hasResponse) {
    ucInterfaceContent += "import '../entity/${snake}_entity.dart';\n";
  }
  ucInterfaceContent += "\n";
  ucInterfaceContent += 'abstract class ${pascal}UseCase {\n';
  if (hasRequest) {
    ucInterfaceContent +=
        "  Future<${returnTypeUc}> call({required ${pascal}Request request});\n";
  } else {
    ucInterfaceContent += "  Future<${returnTypeUc}> call();\n";
  }
  ucInterfaceContent += '}\n';
  ucInterface.writeAsStringSync(ucInterfaceContent);

  final ucImpl = File(p.join(usecaseDir, '${snake}_usecase_impl.dart'));
  // Use feature name for repository type and import from data layer
  final featurePascalForUc = ReCase(featureName).pascalCase;
  // Build imports with optional request model, entity, and Either/Failure
  String ucImplContent =
      '''
/// Generated by scout
/// Author: $author
/// Date  : $today
/// File  : ${snake}_usecase_impl.dart

import '${snake}_usecase.dart';
import '../../data/repository/${featureSnake}_repository.dart';
''';
  if (hasRequest) {
    ucImplContent +=
        "import '../../data/model/request/${snake}_request.dart';\n";
  }
  ucImplContent += "import 'package:fpdart/fpdart.dart';\n";
  ucImplContent += "import '../../../../core/error/failures.dart';\n";
  if (hasResponse) {
    ucImplContent += "import '../entity/${snake}_entity.dart';\n";
  }
  ucImplContent +=
      '''

class ${pascal}UseCaseImpl implements ${pascal}UseCase {
  final ${featurePascalForUc}Repository repo;
  ${pascal}UseCaseImpl(this.repo);

  @override
  Future<${returnTypeUc}> call(${hasRequest ? '{required ${pascal}Request request}' : ''}) async {
''';
  if (hasRequest) {
    ucImplContent +=
        "    final result = await repo.$camel(request: request);\n    return result;\n";
  } else {
    ucImplContent +=
        "    final result = await repo.$camel();\n    return result;\n";
  }
  ucImplContent += '''
  }
}
''';
  ucImpl.writeAsStringSync(ucImplContent);

  // repository append
  final repoFile = File(
    config.repository.replaceAll('features_name', featureSnake) +
        '/${featureSnake}_repository.dart',
  );
  if (repoFile.existsSync()) {
    var content = repoFile.readAsStringSync();

    // Check if imports are needed
    bool hasFpdartImport = content.contains(
      "import 'package:fpdart/fpdart.dart'",
    );
    bool hasFailureImport = content.contains(
      "import '../../../../core/error/failures.dart'",
    );

    // Check for response, request, and entity imports
    bool hasResponseImport = false;
    bool hasRequestImport = false;
    bool hasEntityImport = false;

    if (hasResponse) {
      hasResponseImport = content.contains(
        "import '../../data/model/response/${snake}_response.dart'",
      );
    }

    if (hasRequest) {
      hasRequestImport = content.contains(
        "import '../../data/model/request/${snake}_request.dart'",
      );
    }

    // Build imports to add
    String importsToAdd = '';
    if (!hasFpdartImport) {
      importsToAdd += "import 'package:fpdart/fpdart.dart';\n";
    }
    if (!hasFailureImport) {
      importsToAdd += "import '../../../../core/error/failures.dart';\n";
    }
    // Entity import path from domain/repository -> domain/entity (usecase-based filename)
    hasEntityImport = content.contains(
      "import '../../domain/entity/${snake}_entity.dart'",
    );
    if (!hasEntityImport) {
      importsToAdd += "import '../../domain/entity/${snake}_entity.dart';\n";
    }

    // Add response, request, and entity imports if needed
    // Intentionally skip adding response import for repository interface

    if (hasRequest && !hasRequestImport) {
      importsToAdd +=
          "import '../../data/model/request/${snake}_request.dart';\n";
    }

    // Add imports if needed
    if (importsToAdd.isNotEmpty) {
      // Find the end of the imports section
      final importEndIndex = content.indexOf('\n\n');
      if (importEndIndex != -1) {
        content =
            content.substring(0, importEndIndex) +
            '\n' +
            importsToAdd +
            content.substring(importEndIndex);
      }
    }

    // Prepare the method signature
    final featurePascal = ReCase(featureName).pascalCase;
    String methodSignature;
    if (hasRequest && hasResponse) {
      // Check if response is likely to be a list based on class name (plural form)
      bool isList = pascal.endsWith('s') || pascal.contains('List');
      if (isList) {
        methodSignature =
            "Future<Either<Failure, List<${pascal}Entity>>> $camel({\n    required ${pascal}Request request,\n  });";
      } else {
        methodSignature =
            "Future<Either<Failure, ${pascal}Entity>> $camel({\n    required ${pascal}Request request,\n  });";
      }
    } else if (hasRequest && !hasResponse) {
      methodSignature =
          "Future<Either<Failure, void>> $camel({\n    required ${pascal}Request request,\n  });";
    } else if (!hasRequest && hasResponse) {
      // Check if response is likely to be a list based on class name (plural form)
      bool isList = pascal.endsWith('s') || pascal.contains('List');
      if (isList) {
        methodSignature =
            "Future<Either<Failure, List<${pascal}Entity>>> $camel();";
      } else {
        methodSignature = "Future<Either<Failure, ${pascal}Entity>> $camel();";
      }
    } else {
      methodSignature = "Future<Either<Failure, void>> $camel();";
    }

    // Completely rebuild the repository file to ensure correct structure
    // Extract the class name from the file
    final classNameRegex = RegExp(r'abstract class (\w+Repository)');
    final classNameMatch = classNameRegex.firstMatch(content);
    String className = "${pascal}Repository";
    if (classNameMatch != null && classNameMatch.groupCount >= 1) {
      className = classNameMatch.group(1) ?? className;
    }

    // Extract existing methods safely between class opening brace and last closing brace
    String existingMethods = "";
    final classDecl = RegExp(
      r'abstract class \\w+Repository\\s*\\{',
    ).firstMatch(content);
    if (classDecl != null) {
      final classOpenBraceIdx = content.indexOf('{', classDecl.start);
      final classCloseBraceIdx = content.lastIndexOf('}');
      if (classOpenBraceIdx != -1 &&
          classCloseBraceIdx != -1 &&
          classCloseBraceIdx > classOpenBraceIdx) {
        existingMethods = content.substring(
          classOpenBraceIdx + 1,
          classCloseBraceIdx,
        );
      }
    }
    // Avoid duplicates
    if (existingMethods.contains(methodSignature)) {
      return;
    }

    // Extract imports
    final importsEndIndex = content.indexOf('\n\nabstract');
    String imports = "";
    if (importsEndIndex != -1) {
      imports = content.substring(
        0,
        importsEndIndex + 2,
      ); // Include the double newline
    } else {
      // If we can't find the abstract class declaration, use a default import section
      imports =
          "/// Generated by scout\n/// Author: $author\n/// Date  : $today\n/// File  : ${featureSnake}_repository.dart\n";
      if (hasFpdartImport) imports += "import 'package:fpdart/fpdart.dart';\n";
      if (hasFailureImport)
        imports += "import '../../../../core/error/failures.dart';\n";
      imports += "\n";
    }

    // Build the new content with proper structure
    // Ensure a newline between existing methods and the new method if needed
    final existingBlock = existingMethods.trim().isEmpty
        ? ""
        : existingMethods.trimRight() +
              (existingMethods.endsWith('\n') ? '' : '\n');
    final newContent =
        imports +
        "abstract class $className {\n" +
        existingBlock +
        "  $methodSignature\n" +
        "}\n";

    repoFile.writeAsStringSync(newContent);
  }

  final dsFile = File(
    config.datasource.replaceAll('features_name', featureSnake) +
        '/${featureSnake}_remote_datasource.dart',
  );

  // Create datasource file if it doesn't exist
  if (!dsFile.existsSync()) {
    // Create the directory if it doesn't exist
    final dsDir = Directory(
      config.datasource.replaceAll('features_name', featureSnake),
    );
    dsDir.createSync(recursive: true);

    // Define featurePascal for datasource class name
    final featurePascal = ReCase(featureName).pascalCase;

    // Create initial imports
    String imports =
        "/// Generated by scout\n/// Author: $author\n/// Date  : $today\n/// File  : ${featureSnake}_remote_datasource.dart\n\n";

    // Add necessary imports
    if (hasRequest) {
      imports += "import '../model/request/${snake}_request.dart';\n";
    }
    if (hasResponse) {
      imports += "import '../model/response/${snake}_response.dart';\n";
    }

    // Create the file with basic structure
    dsFile.writeAsStringSync(
      imports + "\nabstract class ${featurePascal}RemoteDataSource {\n  \n}\n",
    );
  }

  if (dsFile.existsSync()) {
    var content = dsFile.readAsStringSync();

    // Check for response and request imports
    bool hasResponseImport = false;
    bool hasRequestImport = false;

    if (hasResponse) {
      hasResponseImport = content.contains(
        "import '../model/response/${snake}_response.dart'",
      );
    }

    if (hasRequest) {
      hasRequestImport = content.contains(
        "import '../model/request/${snake}_request.dart'",
      );
    }

    // Build imports to add
    String importsToAdd = '';

    // Add response and request imports if needed
    if (hasResponse && !hasResponseImport) {
      importsToAdd += "import '../model/response/${snake}_response.dart';\n";
    }

    if (hasRequest && !hasRequestImport) {
      importsToAdd += "import '../model/request/${snake}_request.dart';\n";
    }

    // Add imports if needed
    if (importsToAdd.isNotEmpty) {
      // Find the end of the imports section
      final importEndIndex = content.indexOf('\n\n');
      if (importEndIndex != -1) {
        final newContent =
            content.substring(0, importEndIndex) +
            '\n' +
            importsToAdd +
            content.substring(importEndIndex);
        dsFile.writeAsStringSync(newContent);
        // Keep in-memory content in sync to avoid overwriting the just-added imports below
        content = newContent;
      } else {
        // Fallback: no clear separator found; prepend imports at the top
        final newContent = importsToAdd + '\n' + content;
        dsFile.writeAsStringSync(newContent);
        content = newContent;
      }
    }

    final closingBracketIndex = content.lastIndexOf('}');

    if (closingBracketIndex != -1) {
      // Create method signature in datasource interface
      String methodSignature;
      if (hasRequest && hasResponse) {
        // Check if response is likely to be a list based on class name (plural form)
        bool isList = pascal.endsWith('s') || pascal.contains('List');
        if (isList) {
          methodSignature =
              "\n  Future<List<${pascal}Response>> $camel({required ${pascal}Request request});\n";
        } else {
          methodSignature =
              "\n  Future<${pascal}Response> $camel({required ${pascal}Request request});\n";
        }
      } else if (hasRequest && !hasResponse) {
        methodSignature =
            "\n  Future<void> $camel({required ${pascal}Request request});\n";
      } else if (!hasRequest && hasResponse) {
        // Check if response is likely to be a list based on class name (plural form)
        bool isList = pascal.endsWith('s') || pascal.contains('List');
        if (isList) {
          methodSignature = "\n  Future<List<${pascal}Response>> $camel();\n";
        } else {
          methodSignature = "\n  Future<${pascal}Response> $camel();\n";
        }
      } else {
        methodSignature = "\n  Future<void> $camel();\n";
      }

      final newContent =
          content.substring(0, closingBracketIndex) +
          methodSignature +
          content.substring(closingBracketIndex);

      dsFile.writeAsStringSync(newContent);
    }
  }

  // Create or update implementation file for datasource
  final dsImplFile = File(
    config.datasource.replaceAll('features_name', featureSnake) +
        '/${featureSnake}_remote_datasource_impl.dart',
  );

  if (dsImplFile.existsSync()) {
    // Read existing content
    var content = dsImplFile.readAsStringSync();

    // Check if imports are needed
    bool hasDioClientImport =
        content.contains("import 'package:dio/dio.dart'") ||
        content.contains("import '../../../core/client/dio_client.dart'");
    bool hasEndpointsImport = content.contains(
      "import '../../../core/client/api_path.dart'",
    );
    bool hasRequestImport =
        hasRequest &&
        !content.contains("import '../model/request/${snake}_request.dart'");
    bool hasResponseImport =
        hasResponse &&
        !content.contains("import '../model/response/${snake}_response.dart'");

    // Build imports to add
    String importsToAdd = '';
    if (!hasDioClientImport) {
      importsToAdd += "import '../../../../core/client/dio_client.dart';\n";
    }
    if (!hasEndpointsImport) {
      importsToAdd += "import '../../../../core/client/api_path.dart';\n";
    }
    if (hasRequestImport) {
      importsToAdd += "import '../model/request/${snake}_request.dart';\n";
    }
    if (hasResponseImport) {
      importsToAdd += "import '../model/response/${snake}_response.dart';\n";
    }

    // Add imports if needed
    if (importsToAdd.isNotEmpty) {
      final importEndIndex = content.indexOf('\n\n');
      if (importEndIndex != -1) {
        content =
            content.substring(0, importEndIndex) +
            '\n' +
            importsToAdd +
            content.substring(importEndIndex);
      } else {
        // Fallback: prepend imports at the top
        content = importsToAdd + '\n' + content;
      }
      dsImplFile.writeAsStringSync(content);
    }

    // Check if the class closing bracket exists
    final closingBracketIndex = content.lastIndexOf('}');

    if (closingBracketIndex != -1) {
      // Create method implementation in datasource_impl
      String methodImplementation;
      if (hasRequest && hasResponse) {
        // Check if response is likely to be a list based on class name (plural form)
        bool isList = pascal.endsWith('s') || pascal.contains('List');
        if (isList) {
          methodImplementation =
              '\n  @override\n  Future<List<${pascal}Response>> $camel({\n    required ${pascal}Request request,\n  }) async {\n' +
              '    final resp = await DioClient().apiCall(\n' +
              '        url: Endpoints.$camel,\n' +
              '        requestType: RequestType.$httpMethod,\n' +
              '        body: request.toJson(),\n' +
              '    );\n' +
              '    return (resp.data["data"] as List).map((item) => ${pascal}Response.fromJson(item)).toList();\n' +
              '  }\n';
        } else {
          methodImplementation =
              '\n  @override\n  Future<${pascal}Response> $camel({\n    required ${pascal}Request request,\n  }) async {\n' +
              '    final resp = await DioClient().apiCall(\n' +
              '        url: Endpoints.$camel,\n' +
              '        requestType: RequestType.$httpMethod,\n' +
              '        body: request.toJson(),\n' +
              '    );\n' +
              '    return ${pascal}Response.fromJson(resp.data["data"]);\n' +
              '  }\n';
        }
      } else if (hasRequest && !hasResponse) {
        methodImplementation =
            '\n  @override\n  Future<void> $camel({\n    required ${pascal}Request request,\n  }) async {\n' +
            '    final resp = await DioClient().apiCall(\n' +
            '        url: Endpoints.$camel,\n' +
            '        requestType: RequestType.$httpMethod,\n' +
            '        body: request.toJson(),\n' +
            '    );\n' +
            '    return;\n' +
            '  }\n';
      } else if (!hasRequest && hasResponse) {
        // Check if response is likely to be a list based on class name (plural form)
        bool isList = pascal.endsWith('s') || pascal.contains('List');
        if (isList) {
          methodImplementation =
              '\n  @override\n  Future<List<${pascal}Response>> $camel() async {\n' +
              '    final resp = await DioClient().apiCall(\n' +
              '        url: Endpoints.$camel,\n' +
              '        requestType: RequestType.$httpMethod,\n' +
              '    );\n' +
              '    return (resp.data["data"] as List).map((item) => ${pascal}Response.fromJson(item)).toList();\n' +
              '  }\n';
        } else {
          methodImplementation =
              '\n  @override\n  Future<${pascal}Response> $camel() async {\n' +
              '    final resp = await DioClient().apiCall(\n' +
              '        url: Endpoints.$camel,\n' +
              '        requestType: RequestType.$httpMethod,\n' +
              '    );\n' +
              '    return ${pascal}Response.fromJson(resp.data["data"]);\n' +
              '  }\n';
        }
      } else {
        methodImplementation =
            '\n  @override\n  Future<void> $camel() async {\n' +
            '    final resp = await DioClient().apiCall(\n' +
            '        url: Endpoints.$camel,\n' +
            '        requestType: RequestType.$httpMethod,\n' +
            '    );\n' +
            '    return;\n' +
            '  }\n';
      }

      final newContent =
          content.substring(0, closingBracketIndex) +
          methodImplementation +
          content.substring(closingBracketIndex);

      dsImplFile.writeAsStringSync(newContent);
    }
  }

  // Create repository implementation file
  final repoImplFile = File(
    config.repository.replaceAll('features_name', featureSnake) +
        '/${featureSnake}_repository_impl.dart',
  );

  if (repoImplFile.existsSync()) {
    // Read existing content
    var content = repoImplFile.readAsStringSync();

    // Check if imports are needed
    bool hasFpdartImport = content.contains(
      "import 'package:fpdart/fpdart.dart'",
    );
    bool hasFailureImport = content.contains(
      "import '../../../../core/error/failures.dart'",
    );
    bool hasRemoteProcessImport = content.contains(
      "import '../../../../core/error/remote_process.dart'",
    );
    bool hasDatasourceImport = content.contains(
      "import '../datasource/${featureSnake}_remote_datasource.dart'",
    );
    // Entity import for repo_impl (data/repository -> domain/entity, usecase-based filename)
    bool hasRepoImplEntityImport = content.contains(
      "import '../../domain/entity/${snake}_entity.dart'",
    );
    // Model import checks (repo_impl lives in data/repository -> models in ../model/...)
    bool hasRepoImplRequestImport =
        hasRequest &&
        content.contains("import '../model/request/${snake}_request.dart'");
    bool hasRepoImplResponseImport =
        hasResponse &&
        content.contains("import '../model/response/${snake}_response.dart'");

    // Build imports to add
    String importsToAdd = '';
    if (!hasFpdartImport) {
      importsToAdd += "import 'package:fpdart/fpdart.dart';\n";
    }
    if (!hasFailureImport) {
      importsToAdd += "import '../../../../core/error/failures.dart';\n";
    }
    if (!hasRemoteProcessImport) {
      importsToAdd += "import '../../../../core/error/remote_process.dart';\n";
    }
    if (!hasDatasourceImport) {
      importsToAdd +=
          "import '../datasource/${featureSnake}_remote_datasource.dart';\n";
    }
    if (!hasRepoImplEntityImport) {
      importsToAdd += "import '../../domain/entity/${snake}_entity.dart';\n";
    }
    if (hasRequest && !hasRepoImplRequestImport) {
      importsToAdd += "import '../model/request/${snake}_request.dart';\n";
    }
    // Intentionally skip adding response import for repository_impl

    // Remove response import if present (repo_impl should not import response)
    final repoImplResponseImportLine =
        "import '../model/response/${snake}_response.dart';";
    bool removedResponseImport = false;
    if (content.contains(repoImplResponseImportLine)) {
      content = content.replaceAll(repoImplResponseImportLine + "\n", '');
      content = content.replaceAll(repoImplResponseImportLine, '');
      removedResponseImport = true;
    }

    // Add imports if needed
    if (importsToAdd.isNotEmpty) {
      final importEndIndex = content.indexOf('\n\n');
      if (importEndIndex != -1) {
        content =
            content.substring(0, importEndIndex) +
            '\n' +
            importsToAdd +
            content.substring(importEndIndex);
      } else {
        content = importsToAdd + '\n' + content;
      }
    }
    if (importsToAdd.isNotEmpty || removedResponseImport) {
      repoImplFile.writeAsStringSync(content);
    }

    // Extract the actual feature name from the file path
    // Convert snake_case to PascalCase for the feature name
    final featureNameParts = featureSnake.split('_');
    final featurePascal = featureNameParts
        .map(
          (part) =>
              part.isNotEmpty ? part[0].toUpperCase() + part.substring(1) : '',
        )
        .join('');

    // Check if the class has remoteDataSource field
    bool hasRemoteDataSourceField = content.contains(
      "final ${featurePascal}RemoteDataSource remoteDataSource",
    );

    // Check if the class closing bracket exists
    var closingBracketIndex = content.lastIndexOf('}');

    // Find class opening bracket
    final classRegex = RegExp(r'class \w+RepositoryImpl[^{]*\{');
    final classMatch = classRegex.firstMatch(content);
    int classOpeningBracketIndex = -1;

    if (classMatch != null) {
      classOpeningBracketIndex = classMatch.end - 1;
    }

    if (closingBracketIndex != -1 && classOpeningBracketIndex != -1) {
      // Add remoteDataSource field if it doesn't exist
      String fieldDeclaration = '';
      if (!hasRemoteDataSourceField) {
        fieldDeclaration =
            '\n  final ${featurePascal}RemoteDataSource remoteDataSource;\n\n  ${featurePascal}RepositoryImpl({required this.remoteDataSource});\n';
      }

      // Insert the new method before the closing bracket
      String methodImplementation;
      if (hasRequest && hasResponse) {
        // Check if response is likely to be a list based on class name (plural form)
        bool isList = pascal.endsWith('s') || pascal.contains('List');
        if (isList) {
          methodImplementation =
              '\n  @override\n  Future<Either<Failure, List<${pascal}Entity>>> $camel({\n    required ${pascal}Request request,\n  }) async {\n' +
              '    final resp = await remoteProcess(\n' +
              '      remoteDataSource.$camel(request: request),\n' +
              '    );\n' +
              '    return resp.fold(\n' +
              '      (failure) => Left(failure),\n' +
              '      (data) => Right(data.map((e) => ${pascal}Entity.fromResponse(e)).toList()),\n' +
              '    );\n' +
              '  }\n';
        } else {
          methodImplementation =
              '\n  @override\n  Future<Either<Failure, ${pascal}Entity>> $camel({\n    required ${pascal}Request request,\n  }) async {\n' +
              '    final resp = await remoteProcess(\n' +
              '      remoteDataSource.$camel(request: request),\n' +
              '    );\n' +
              '    return resp.fold(\n' +
              '      (failure) => Left(failure),\n' +
              '      (data) => Right(${pascal}Entity.fromResponse(data)),\n' +
              '    );\n' +
              '  }\n';
        }
      } else if (hasRequest && !hasResponse) {
        methodImplementation =
            '\n  @override\n  Future<Either<Failure, void>> $camel({\n    required ${pascal}Request request,\n  }) async {\n' +
            '    final resp = await remoteProcess(\n' +
            '      remoteDataSource.$camel(request: request),\n' +
            '    );\n' +
            '    return resp.fold(\n' +
            '      (failure) => Left(failure),\n' +
            '      (data) => Right(data),\n' +
            '    );\n' +
            '  }\n';
      } else if (!hasRequest && hasResponse) {
        // Check if response is likely to be a list based on class name (plural form)
        bool isList = pascal.endsWith('s') || pascal.contains('List');
        if (isList) {
          methodImplementation =
              "\n  @override\n  Future<Either<Failure, List<${pascal}Entity>>> $camel() async {\n" +
              '    final resp = await remoteProcess(\n' +
              '      remoteDataSource.$camel(),\n' +
              '    );\n' +
              '    return resp.fold(\n' +
              '      (failure) => Left(failure),\n' +
              '      (data) => Right(data.map((e) => ${pascal}Entity.fromResponse(e)).toList()),\n' +
              '    );\n' +
              '  }\n';
        } else {
          methodImplementation =
              "\n  @override\n  Future<Either<Failure, ${pascal}Entity>>> $camel() async {\n" +
              '    final resp = await remoteProcess(\n' +
              '      remoteDataSource.$camel(),\n' +
              '    );\n' +
              '    return resp.fold(\n' +
              '      (failure) => Left(failure),\n' +
              '      (data) => Right(${pascal}Entity.fromResponse(data)),\n' +
              '    );\n' +
              '  }\n';
        }
      } else {
        methodImplementation =
            '\n  @override\n  Future<Either<Failure, void>> $camel() async {\n' +
            '    final resp = await remoteProcess(\n' +
            '      remoteDataSource.$camel(),\n' +
            '    );\n' +
            '    return resp.fold(\n' +
            '      (failure) => Left(failure),\n' +
            '      (data) => Right(data),\n' +
            '    );\n' +
            '  }\n';
      }

      // If we need to add the field, add it right after the class opening bracket
      if (!hasRemoteDataSourceField && classOpeningBracketIndex != -1) {
        content =
            content.substring(0, classOpeningBracketIndex + 1) +
            fieldDeclaration +
            content.substring(classOpeningBracketIndex + 1);

        // Adjust the closing bracket index since we added content
        closingBracketIndex += fieldDeclaration.length;
      }

      final newContent =
          content.substring(0, closingBracketIndex) +
          methodImplementation +
          content.substring(closingBracketIndex);

      repoImplFile.writeAsStringSync(newContent);
    }
  }

  // Create api_path.dart if it doesn't exist
  if (!apiPathFile.existsSync()) {
    apiPathFile.writeAsStringSync('''
/// Generated by scout
/// Author: $author
/// Date  : $today
/// File  : api_path.dart

class Endpoints {
  // Base URL
  static const String baseUrl = '$baseUrl';
  
  // Add your endpoints here
  static const String $camel = '$endpoint';
}
''');
  } else {
    // Update existing api_path.dart with new endpoint
    final content = apiPathFile.readAsStringSync();
    final closingBracketIndex = content.lastIndexOf('}');

    if (closingBracketIndex != -1) {
      final newContent =
          content.substring(0, closingBracketIndex) +
          '  static const String $camel = \'$endpoint\';\n' +
          content.substring(closingBracketIndex);

      apiPathFile.writeAsStringSync(newContent);
    }
  }

  // Create dio_client.dart if it doesn't exist
  final dioClientFile = File(p.join(clientDir, 'dio_client.dart'));
  if (!dioClientFile.existsSync()) {
    dioClientFile.writeAsStringSync('''
/// Generated by scout
/// Author: $author
/// Date  : $today
/// File  : dio_client.dart

import 'package:dio/dio.dart';
import 'api_path.dart';

enum RequestType { get, post, put, delete }

class DioClient {
  static final DioClient _instance = DioClient._internal();
  late Dio _dio;

  factory DioClient() => _instance;

  DioClient._internal() {
    _dio = Dio(
      BaseOptions(
        baseUrl: Endpoints.baseUrl,
        connectTimeout: const Duration(seconds: 30),
        receiveTimeout: const Duration(seconds: 30),
        headers: <String, dynamic>{
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      ),
    );
  }

  Future<Response> apiCall({
    required String url,
    required RequestType requestType,
    Map<String, dynamic>? body,
    Map<String, dynamic>? queryParameters,
    Options? options,
  }) async {
    Response response;

    try {
      switch (requestType) {
        case RequestType.get:
          response = await _dio.get(
            url,
            queryParameters: queryParameters,
            options: options,
          );
          break;
        case RequestType.post:
          response = await _dio.post(
            url,
            data: body,
            queryParameters: queryParameters,
            options: options,
          );
          break;
        case RequestType.put:
          response = await _dio.put(
            url,
            data: body,
            queryParameters: queryParameters,
            options: options,
          );
          break;
        case RequestType.delete:
          response = await _dio.delete(
            url,
            data: body,
            queryParameters: queryParameters,
            options: options,
          );
          break;
      }
      return response;
    } on DioException catch (e) {
      rethrow;
    }
  }
}
''');
  }

  stdout.writeln('[✓] Usecase "$pascal" generated');
  stdout.writeln('[✓] API client files generated in $clientDir');
  stdout.writeln('[✓] Endpoint "$camel" added to api_path.dart');
  stdout.writeln('[✓] HTTP method: $httpMethod');
}
